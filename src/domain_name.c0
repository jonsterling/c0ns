#use "bit_utils.c0"

struct domain_name {
    string label;
    int size;
    struct domain_name* next;
};

typedef struct domain_name* domain_name;

int domain_size(domain_name name) {
    if (name == NULL) {
        return 0;
    }

    return name->size;
}

domain_name domain_nil() {
    return NULL;
}

domain_name domain_cons(string lbl, domain_name name) {
    domain_name d = alloc(struct domain_name);
    d->label = lbl;
    d->next = name;
    d->size = domain_size(name) + string_length(lbl);
    return d;
}

domain_name parse_domain_name_aux(domain_name name, int* cursor, int[] data)
//@requires cursor != NULL;
//@requires *cursor < \length(data) * 32;
{
    int* len = alloc(int);

    int orig_cursor = *cursor;

    *cursor = read_bits(*cursor, data, 8, len);

    if (*len == 0) {
        return name;
    }

    if (*len >= 0xc0) {
        // case: pointer
        int* ptr = alloc(int);
        // read the remainder of the first 16 bits as a pointer to an offset in octets
        *cursor = read_bits(orig_cursor + 2, data, 14, ptr);
        // read the last label of the domain name from the pointer:

        int* ptrCursor = alloc(int);
        *ptrCursor = *ptr * 8;

        return parse_domain_name_aux(name, ptrCursor, data);
    }

    // char arrays by convention must end in a null cell, so we allocate *len + 1.
    char[] chars = alloc_array(char, *len + 1);

    // case: ordinary label
    // now '*len' specifies the number of octets in the label
    for (int i = 0; i < *len; i++) {
        int* octet = alloc(int);
        *cursor = read_bits(*cursor, data, 8, octet);

        // This should never be negative! WTF?
        assert(*octet >= 0);
        chars[i] = char_chr(*octet);
    }


    string lbl = string_from_chararray(chars);
    return parse_domain_name_aux(domain_cons(lbl, name), cursor, data);
}


domain_name parse_domain_name(int* cursorOut, int[] data)
//@requires cursorOut != NULL;
//@requires *cursorOut < \length(data) * 32;
{
    return parse_domain_name_aux(domain_nil(), cursorOut, data);
}

int print_domain_name(int cursor, int[] data, domain_name d)
//@requires cursor < \length(data) * 32;
//@requires cursor % 8 == 0;
{
    domain_name ptr;
    domain_name tail=NULL;
    int x=0;
    while (d!=tail) {
        ptr = d;
        while (ptr->next!=tail)
            ptr = ptr -> next;
        cursor = write_string (cursor, data, ptr->label);
        x= ptr->size;
        tail = ptr;
    }

    cursor = write_bits(cursor, data, 8, 0); //final label, for root
    return cursor;
}

void assert_domain_eq(domain_name dn1, domain_name dn2) {
    if (dn1 == NULL){
        assert(dn2 == NULL);
        return;
    }

    assert(string_equal(dn1->label, dn2->label));
    assert_domain_eq(dn2->next, dn2->next);
}

void debug_domain_name(domain_name dn) {
    if (dn == NULL) {
        print("[]");
    }
    else {
        print(dn->label);
        print(".");
        debug_domain_name(dn->next);
    }
}

void test_domain_name() {
    domain_name dn = domain_cons("ab", domain_nil());
    int[] data = alloc_array(int, 30);
    int cursor = print_domain_name(0, data, dn);

    int* cursorOut = alloc(int);
    domain_name dn2 = parse_domain_name(cursorOut, data);

    assert_domain_eq(dn, dn2);

    println("* test_domain_name passed");
}