#use <conio>

#use "header.c0"
#use "resource_record.c1"
#use "bit_utils.c0"
#use "question.c0"
#use "cursor.c0"

struct message {
    header header;
    question[] question;
    resource_record[] answer;
    resource_record[] authority;
    resource_record[] additional;
};

typedef struct message* message;


message parse_message(int[] data)
//@ensures \result != NULL;
{
    cursor cur = cursor_new(0);

    message msg = alloc(struct message);
    msg->header = parse_header(cur, data);
    header hd = msg->header;

    msg->question = alloc_array(question, hd->qdcount);
    msg->answer = alloc_array(resource_record, hd->ancount);
    msg->authority = alloc_array(resource_record, hd->nscount);
    msg->additional = alloc_array(resource_record, hd->arcount);

    for (int i = 0; i < hd->qdcount; i++) {
        msg->question[i] = parse_question(cur, data);
    }

    for (int i = 0; i < hd->ancount; i++) {
        msg->answer[i] = parse_resource_record(cur, data);
    }

    for (int i = 0; i < hd->nscount; i++) {
        msg->authority[i] = parse_resource_record(cur, data);
    }

    for (int i = 0; i < hd->arcount; i++) {
        msg->additional[i] = parse_resource_record(cur, data);
    }

    return msg;
}

// For arrays where we need to know the length.
struct bytearray {
    int length;
    int[] bytes;
};

typedef struct bytearray* bytearray;

int estimate_message_size(message msg)
//@requires msg != NULL;
{
    header hd = msg->header;

    int headerBits = 6 * 16;
    int numBits = headerBits;

    for (int i = 0; i < hd->qdcount; i++) {
        numBits += countBitsQuestion(msg->question[i]);
    }

    for (int i = 0; i < hd->ancount; i++) {
        numBits += countBitsRR(msg->answer[i]);
    }

    for (int i = 0; i < hd->nscount; i++) {
        numBits += countBitsRR(msg->authority[i]);
    }

    for (int i = 0; i < hd->arcount; i++) {
        numBits += countBitsRR(msg->additional[i]);
    }


    return numBits;
}

bytearray write_message(message msg)
//@requires msg != NULL;
//@ensures \result != NULL;
{
    header hd = msg->header;
    int numBits = estimate_message_size(msg);

    // multiplied by 2 just in case ;-)
    int destDataLen=(numBits/32)*2;
    int[] destData = alloc_array(int, (numBits/32)*2);

    cursor cur = cursor_new(0);
    print_header(cur, destData, msg->header);

    for (int i = 0; i < hd->qdcount; i++) {
        print_question(cur, destData, msg->question[i]);
    }

    for (int i = 0; i < hd->ancount; i++) {
        print_resource_record(cur, destData, msg->answer[i]);
    }

    for (int i = 0; i < hd->nscount; i++) {
        print_resource_record(cur, destData, msg->authority[i]);
    }

    for (int i = 0; i < hd->arcount; i++) {
        print_resource_record(cur, destData, msg->additional[i]);
    }

    int position=0;
    for(int i=0; i<destDataLen;i++){
        if(destData[i]==0 && position==0){
            position=i;
        }
        else if(destData[i]!=0){
            position=0;
        }
    }

    bytearray dest = alloc(struct bytearray);
    //dest->length = numBits/32;
    dest->length = position/32;
    dest->bytes = destData;

    return dest;
}

void debug_bytearray(bytearray bs)
//@requires bs != NULL;
{
    print("[");
    for (int i = 0; i < bs->length; i++) {
        if (i != 0) {
            print(" | ");
        }
        else {
            print(" ");
        }

        printint(bs->bytes[i]);
    }
    print(" ]");
    flush();
}

void assert_bytes_eq(bytearray bs1, bytearray bs2)
//@requires bs1 != NULL && bs2 != NULL;
{
    int l1 = bs1->length;
    int l2 = bs2->length;

    if (l1 != l2) {
        print("Equating following two byte arrays: \n    ");
        debug_bytearray(bs1);
        print("\nvs.\n    ");
        debug_bytearray(bs2);
        print("\n");

        string msg = "Byte arrays of different lengths: ";
        msg = string_join(msg, string_fromint(l1));
        msg = string_join(msg, " vs. ");
        msg = string_join(msg, string_fromint(l2));
        error(msg);
    }

    for (int i = 0; i < l1; i++) {
        int x1 = bs1->bytes[i];
        int x2 = bs2->bytes[i];

        if (x1 != x2) {
            print("Equating following two byte arrays: \n ");
            debug_bytearray(bs1);
            print("\nvs.\n    ");
            debug_bytearray(bs2);
            print("\n");

            error("Test failed");
            //break;
        }
    }
}


void test_roundtrip(message msg)
//@requires msg != NULL;
{

    bytearray bs = write_message(msg);
    message msg2 = parse_message(bs->bytes);
    bytearray bs2 = write_message(msg2);

    assert_bytes_eq(bs, bs2);
}
