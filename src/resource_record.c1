#use <string>
#use "types.c0"
#use "class.c0"
#use "domain_name.c0"
#use "bit_utils.c0"

struct rr_txt {
    string txt;
    struct rr_txt* next;
};

typedef struct rr_txt* rr_txt;

rr_txt rr_txt_nil() {
    return NULL;
}

rr_txt rr_txt_cons(string s, rr_txt txt) {
    rr_txt t = alloc(struct rr_txt);
    t->txt = s;
    t->next = txt;
    return t;
}

struct rr_hinfo {
    string cpu;
    string os;
};

struct rr_mx {
    int preference;
    domain_name exchange;
};

struct rr_soa {
    domain_name mname;
    domain_name rname;
    int serial;
    int refresh;
    int retry;
    int expire;
    int minimum;
};


struct rr_A {
    int address;
};

struct rr_wks {
    int address;
    int protocol;
    int[] bitmap;
};

struct resource_record {
    domain_name name; // a domain name, subject to compression
    type_ type;
    class class;
    int ttl;
    int rd_length;
    void* rdata; // classified by 'type'
};


int parse_hinfo(int cursor, int[] data, struct rr_hinfo* dest)
//@requires cursor <= \length(data) * 32;
{
    string* cpu = alloc(string);
    string* os = alloc(string);

    cursor = read_string(cursor, data, cpu);
    cursor = read_string(cursor, data, os);

    dest->cpu = *cpu;
    dest->os = *os;

    return cursor;
}

int parse_mx(int cursor, int[] data, struct rr_mx* dest)
//@requires cursor <= \length(data) * 32;
{
    int* pref = alloc(int);

    cursor = read_bits(cursor, data, 16, pref);

    int* cursorOut = alloc(int);
    *cursorOut = cursor;

    dest->preference = *pref;
    dest->exchange = parse_domain_name(cursorOut, data);
    cursor = *cursorOut;

    return cursor;
}

int parse_soa(int cursor, int[] data, struct rr_soa* dest)
//@requires cursor <= \length(data) * 32;
{
    int* serial = alloc(int);
    int* refresh = alloc(int);
    int* retry = alloc(int);
    int* expire = alloc(int);

    int* cursorOut = alloc(int);
    *cursorOut = cursor;

    dest->mname = parse_domain_name(cursorOut, data);
    dest->rname = parse_domain_name(cursorOut, data);
    cursor = *cursorOut;

    cursor = read_bits(cursor, data, 32, serial);
    cursor = read_bits(cursor, data, 32, refresh);
    cursor = read_bits(cursor, data, 32, retry);
    cursor = read_bits(cursor, data, 32, expire);

    dest->serial = *serial;
    dest->refresh = *refresh;
    dest->retry = *retry;
    dest->expire = *expire;

    return cursor;
}

int parse_txt(int cursor, int end, int[] data, rr_txt* dest)
//@requires cursor <= \length(data) * 32;
{
    string* s = alloc(string);
    int cursor2 = read_string(cursor, data, s);

    if (cursor2 >= end) {
        *dest = rr_txt_nil();
        return cursor;
    }

    cursor = cursor2;

    rr_txt* init = alloc(rr_txt);
    cursor = parse_txt(cursor, end, data, init);

    *dest = rr_txt_cons(*s, *init);

    return cursor;
}

int parse_A(int cursor, int[] rdata, struct rr_A* dest)
//@requires cursor <= \length(rdata) * 32;
{
    int* address = alloc(int);
    cursor = read_bits(cursor, rdata, 32, address);
    dest->address = *address;
    return cursor;
}

int parse_wks(int cursor, int[] rdata, struct rr_wks* dest)
//@requires cursor <= \length(rdata) * 32;
{
//    error("TODO: wks not yet supported");
    return cursor;
}

int parse_rdata(int cursor, int[] data, type_ type, int len, struct resource_record* dest)
//@requires dest != NULL;
//@requires cursor <= \length(data) * 32;
//@requires cursor % 8 == 0;
{
    if (type == type_cname()) {
        int* cursorOut = alloc(int);
        *cursorOut = cursor;
        domain_name result = parse_domain_name(cursorOut, data);
        dest->rdata = (void*)result;
        cursor = *cursorOut;
    }
    else if (type == type_hinfo()) {
        struct rr_hinfo* hinfo = alloc(struct rr_hinfo);
        cursor = parse_hinfo(cursor, data, hinfo);
        dest->rdata = (void*)hinfo;
    }
    else if (type == type_mx()) {
        struct rr_mx* mx = alloc(struct rr_mx);
        cursor = parse_mx(cursor, data, mx);
        dest->rdata = (void*)mx;
    }
    else if (type == type_ptr()) {
        int* cursorOut = alloc(int);
        *cursorOut = cursor;
        domain_name result = parse_domain_name(cursorOut, data);
        dest->rdata = (void*) result;
        cursor = *cursorOut;
    }
    else if (type == type_soa()) {
        struct rr_soa* soa = alloc(struct rr_soa);
        cursor = parse_soa(cursor, data, soa);
        dest->rdata = (void*)soa;
    }
    else if (type == type_txt()) {
        rr_txt* txt = alloc(rr_txt);
        *txt = NULL; //FARZANEH: last node (with first string) should be pointing to null
        cursor = parse_txt(cursor, cursor + len * 8, data, txt);
        dest->rdata = (void*)txt;
    }
    else if (type == type_A()) {
        struct rr_A* r = alloc(struct rr_A);
        cursor = parse_A(cursor, data, r);
        dest->rdata = (void*)r;
    }
    else if (type == type_wks()) {
        error("TODO: wks");
    }
    else {
        error("parse_rdata: Unsupported RR type");
    }

    return cursor;
}

int parse_resource_record(int cursor, int[] data, struct resource_record* dest)
//@requires dest != NULL;
//@requires cursor <= \length(data) * 32;
{

    int* type = alloc(int);
    int* class_ = alloc(int);
    int* ttl = alloc(int);
    int* rd_length = alloc(int);

    int* cursorOut = alloc(int);
    *cursorOut = cursor;
    dest->name = parse_domain_name(cursorOut, data);
    cursor = *cursorOut;

    cursor = read_bits(cursor, data, 16, type);

    cursor = read_bits(cursor, data, 16, class_);

    cursor = read_bits(cursor, data, 32, ttl);
    cursor = read_bits(cursor, data, 16, rd_length);

    debug_domain_name(dest->name);
    print("\n\n");

    printint(*type);
    print(":type\n");
    printint(*class_);
    print(":class_\n");

    dest->type = *type;
    dest->class = *class_;
    dest->ttl = *ttl;
    dest->rd_length = *rd_length;


    cursor = parse_rdata(cursor, data, *type, *rd_length, dest);

    return cursor;
}


int print_rr_txt (int cursor, int[] data, rr_txt t)
//@requires cursor <= \length(data) * 32;
{
    rr_txt ptr;
    rr_txt tail=NULL;
    while (t!=tail) {
        ptr = t;
        while (ptr->next!=tail)
            ptr = ptr -> next;
        cursor = write_string (cursor, data, ptr->txt);
        tail = ptr;
    }
    //TODO do we have a root text in the end? uncomment next line
    //cursor = write_bits(cursor, data, 8, 0); //final label, for root
    return cursor;
}


int print_rdata (int cursor, int[] data, type_ type, void* rdata)
//@requires cursor <= \length(data) * 32;
{

    //TODO: this block needs to be checked
    if (type == type_cname()) {
        cursor = print_domain_name(cursor, data, (domain_name)rdata);
    }
    else if (type == type_hinfo()) {
        cursor = write_string(cursor, data, ((struct rr_hinfo*)rdata)->cpu);
        cursor = write_string(cursor, data, ((struct rr_hinfo*)rdata)->os);
    }
    else if (type == type_mx()) {
        cursor = write_bits(cursor, data, 16, ((struct rr_mx*)rdata)->preference);
        cursor = print_domain_name(cursor, data, ((struct rr_mx*)rdata)->exchange);
    }
    else if (type == type_ptr()) {
        cursor = print_domain_name(cursor, data, (domain_name)rdata);
    }
    else if (type == type_soa()) {
        cursor = print_domain_name(cursor, data, ((struct rr_soa*)rdata)->mname);
        cursor = print_domain_name(cursor, data, ((struct rr_soa*)rdata)->rname);
        cursor = write_bits(cursor, data, 32, ((struct rr_soa*)rdata)->serial);
        cursor = write_bits(cursor, data, 32, ((struct rr_soa*)rdata)->refresh);
        cursor = write_bits(cursor, data, 32, ((struct rr_soa*)rdata)->retry);
        cursor = write_bits(cursor, data, 32, ((struct rr_soa*)rdata)->expire);
    }

    else if (type == type_txt()) {
        cursor = print_rr_txt(cursor, data, *(( rr_txt*)rdata));
    }
    else if (type == type_A()) {
        cursor = write_bits(cursor, data, 32, ((struct rr_A*)rdata)->address);
    }
    else if (type == type_wks()) {
        error("TODO: wks");
    }
    else {
        error("print_rdata: Unsupported RR type");
    }

    return cursor;
}

int print_resource_record(int cursor, int[] data, struct resource_record* rr)
//@requires rr != NULL;
//@requires cursor <= \length(data) * 32;
{

    cursor = print_domain_name (cursor, data, rr->name);

    cursor = write_bits(cursor, data, 16, rr->type);
    cursor = write_bits(cursor, data, 16, rr->class);
    cursor = write_bits(cursor, data, 32, rr->ttl);
    cursor = write_bits(cursor, data, 16, rr->rd_length);
    cursor = print_rdata(cursor, data, rr->type, rr->rdata);

    return cursor;
}

int countBitsRR(struct resource_record* rr)
//@requires rr != NULL;
{
    //Rsize is in bits
    int Rsize=rr->name->size*8 +16+16+32+16+(rr->rd_length*8);
    return Rsize;
}