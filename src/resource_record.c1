#use <string>
#use "types.c0"
#use "class.c0"
#use "domain_name.c0"
#use "bit_utils.c0"

struct rr_txt {
    string txt;
    struct rr_txt* next;
};

typedef struct rr_txt* rr_txt;

rr_txt rr_txt_nil() {
    return NULL;
}

rr_txt rr_txt_cons(string s, rr_txt txt) {
    rr_txt t = alloc(struct rr_txt);
    t->txt = s;
    t->next = txt;
    return t;
}

struct rr_hinfo {
    string cpu;
    string os;
};

struct rr_mx {
    int preference;
    domain_name exchange;
};

struct rr_soa {
    domain_name mname;
    domain_name rname;
    int serial;
    int refresh;
    int retry;
    int expire;
    int minimum;
};


struct rr_A {
    int address;
};

struct rr_wks {
    int address;
    int protocol;
    int[] bitmap;
};

struct resource_record {
    domain_name name; // a domain name, subject to compression
    type_ type;
    class class;
    int ttl;
    int rd_length;
    void* rdata; // classified by 'type'
};

typedef struct resource_record* resource_record;


struct rr_hinfo* parse_hinfo(int* cursor, int[] data)
//@requires *cursor <= \length(data) * 32;
{
    struct rr_hinfo* dest = alloc(struct rr_hinfo);
    dest->cpu = read_string(cursor, data);
    dest->os = read_string(cursor, data);

    return dest;
}

struct rr_mx* parse_mx(int *cursor, int[] data)
//@requires *cursor <= \length(data) * 32;
{
    struct rr_mx* dest = alloc(struct rr_mx);
    dest->preference = read_bits2(cursor, data, 16);
    dest->exchange = parse_domain_name(cursor, data);
    return dest;
}

struct rr_soa* parse_soa(int *cursor, int[] data)
//@requires *cursor <= \length(data) * 32;
{
    struct rr_soa* dest = alloc(struct rr_soa);
    dest->mname = parse_domain_name(cursor, data);
    dest->rname = parse_domain_name(cursor, data);
    dest->serial = read_bits2(cursor, data, 32);
    dest->refresh = read_bits2(cursor, data, 32);
    dest->retry = read_bits2(cursor, data, 32);
    dest->expire = read_bits2(cursor, data, 32);
    return dest;
}

struct rr_txt* parse_txt(int *cursor, int end, int[] data)
//@requires *cursor <= \length(data) * 32;
{
    int origCursor = *cursor;
    string s = read_string(cursor, data);
    if (*cursor >= end) {
        *cursor = origCursor;
        return rr_txt_nil();
    }

    struct rr_txt* init = parse_txt(cursor, end, data);
    return rr_txt_cons(s, init);
}

struct rr_A* parse_A(int* cursor, int[] rdata)
//@requires *cursor <= \length(rdata) * 32;
{
    struct rr_A* dest = alloc(struct rr_A);
    dest->address = read_bits2(cursor, rdata, 32);
    return dest;
}

struct rr_wks* parse_wks(int *cursor, int[] rdata)
//@requires *cursor <= \length(rdata) * 32;
{
    error("TODO: wks not yet supported");
}

void* parse_rdata(int* cursor, int[] data, type_ type, int len)
//@ensures \result != NULL;
//@requires *cursor <= \length(data) * 32;
//@requires *cursor % 8 == 0;
{
    if (type == type_cname()) {
        return (void*)parse_domain_name(cursor, data);
    }
    else if (type == type_hinfo()) {
        return (void*)parse_hinfo(cursor, data);
    }
    else if (type == type_mx()) {
        return (void*)parse_mx(cursor, data);
    }
    else if (type == type_ptr()) {
        return (void*)parse_domain_name(cursor, data);
    }
    else if (type == type_soa()) {
        return (void*)parse_soa(cursor, data);
    }
    else if (type == type_txt()) {
        return (void*)parse_txt(cursor, *cursor + len * 8, data);
    }
    else if (type == type_A()) {
        return (void*)parse_A(cursor, data);
    }
    else if (type == type_wks()) {
        error("TODO: wks");
    }
    else {
        error("parse_rdata: Unsupported RR type");
    }
}

resource_record parse_resource_record(int* cursor, int[] data)
//@ensures \result != NULL;
//@requires *cursor <= \length(data) * 32;
{
    resource_record dest = alloc(struct resource_record);
    dest->name = parse_domain_name(cursor, data);

    print("\n\n");
    printint(dest->type);
    print(":type\n");
    printint(dest->class);
    print(":class_\n");

    debug_domain_name(dest->name);
    dest->type = read_bits2(cursor, data, 16);
    dest->class = read_bits2(cursor, data, 16);
    dest->ttl = read_bits2(cursor, data, 32);
    dest->rd_length = read_bits2(cursor, data, 16);
    dest->rdata = parse_rdata(cursor, data, dest->type, dest->rd_length);


    return dest;
}


int print_rr_txt (int cursor, int[] data, rr_txt t)
//@requires cursor <= \length(data) * 32;
{
    rr_txt ptr;
    rr_txt tail=NULL;
    while (t!=tail) {
        ptr = t;
        while (ptr->next!=tail)
            ptr = ptr -> next;
        cursor = write_string (cursor, data, ptr->txt);
        tail = ptr;
    }
    //TODO do we have a root text in the end? uncomment next line
    //cursor = write_bits(cursor, data, 8, 0); //final label, for root
    return cursor;
}


int print_rdata (int cursor, int[] data, type_ type, void* rdata)
//@requires cursor <= \length(data) * 32;
{

    //TODO: this block needs to be checked
    if (type == type_cname()) {
        cursor = print_domain_name(cursor, data, (domain_name)rdata);
    }
    else if (type == type_hinfo()) {
        cursor = write_string(cursor, data, ((struct rr_hinfo*)rdata)->cpu);
        cursor = write_string(cursor, data, ((struct rr_hinfo*)rdata)->os);
    }
    else if (type == type_mx()) {
        cursor = write_bits(cursor, data, 16, ((struct rr_mx*)rdata)->preference);
        cursor = print_domain_name(cursor, data, ((struct rr_mx*)rdata)->exchange);
    }
    else if (type == type_ptr()) {
        cursor = print_domain_name(cursor, data, (domain_name)rdata);
    }
    else if (type == type_soa()) {
        cursor = print_domain_name(cursor, data, ((struct rr_soa*)rdata)->mname);
        cursor = print_domain_name(cursor, data, ((struct rr_soa*)rdata)->rname);
        cursor = write_bits(cursor, data, 32, ((struct rr_soa*)rdata)->serial);
        cursor = write_bits(cursor, data, 32, ((struct rr_soa*)rdata)->refresh);
        cursor = write_bits(cursor, data, 32, ((struct rr_soa*)rdata)->retry);
        cursor = write_bits(cursor, data, 32, ((struct rr_soa*)rdata)->expire);
    }

    else if (type == type_txt()) {
        cursor = print_rr_txt(cursor, data, (struct rr_txt*)rdata);
    }
    else if (type == type_A()) {
        cursor = write_bits(cursor, data, 32, ((struct rr_A*)rdata)->address);
    }
    else if (type == type_wks()) {
        error("TODO: wks");
    }
    else {
        error("print_rdata: Unsupported RR type");
    }

    return cursor;
}

int print_resource_record(int cursor, int[] data, struct resource_record* rr)
//@requires rr != NULL;
//@requires cursor <= \length(data) * 32;
{

    cursor = print_domain_name (cursor, data, rr->name);

    cursor = write_bits(cursor, data, 16, rr->type);
    cursor = write_bits(cursor, data, 16, rr->class);
    cursor = write_bits(cursor, data, 32, rr->ttl);
    cursor = write_bits(cursor, data, 16, rr->rd_length);
    cursor = print_rdata(cursor, data, rr->type, rr->rdata);

    return cursor;
}

int countBitsRR(struct resource_record* rr)
//@requires rr != NULL;
{
    //Rsize is in bits
    int Rsize=rr->name->size*8 +16+16+32+16+(rr->rd_length*8);
    return Rsize;
}